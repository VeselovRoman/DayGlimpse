import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, FormArray, Validators } from '@angular/forms';
import { ReportService } from '../_services/report.service';
import { RespondentService } from '../_services/respondent.service';
import { ProcedureService } from '../_services/procedure.service';
import { Respondent } from '../_models/respondent';
import { Entry, Report } from '../_models/report';
import { Procedure } from '../_models/procedures';
import { formatDate } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { ReportStateService } from '../_services/report-state.service';
import { ToastrService } from 'ngx-toastr';

@Component({
  selector: 'app-view-report',
  templateUrl: './view-report.component.html',
  styleUrls: ['./view-report.component.css']
})
export class ViewReportComponent implements OnInit {
  reportForm!: FormGroup;
  respondents: Respondent[] = [];
  procedures: Procedure[] = [];
  reportId!: number;
  report!: Report;
  timeGaps: { start: Date, end: Date, gap: boolean }[] = [];

  constructor(
    private formBuilder: FormBuilder,
    private reportService: ReportService,
    private respondentService: RespondentService,
    private procedureService: ProcedureService,
    private route: ActivatedRoute,
    private router: Router,
    private toastr: ToastrService,
    private reportStateService: ReportStateService
  ) { }

  ngOnInit(): void {
    this.route.params.subscribe(params => {
      this.reportId = +params['id'];
      this.loadReport();
    });
    this.initializeForm();
    this.loadRespondents();
    this.loadProcedures();
  }

  initializeForm(): void {
    this.reportForm = this.formBuilder.group({
      id: [{ value: '', disabled: false }],
      reportDate: [{ value: '', disabled: false }],
      agentName: [{ value: '', disabled: false }],
      respondentName: [{ value: '', disabled: false }],
      isConfirmed: [{ value: '', disabled: false }],
      entries: this.formBuilder.array([])
    });
  }

  loadReport() {
    this.reportService.getReport(this.reportId).subscribe(report => {
      this.report = report;
      this.fillReportForm()
    });
  }

  fillReportForm(): void {
    if (!this.report) {
      console.log('Report is not loaded yet');
      return;
    }

    console.log("fillReport:", this.report);
    this.reportForm.patchValue({
      id: this.report?.id,
      reportDate: this.report?.reportDate,
      agentName: this.report?.agentName,
      respondentName: this.report?.respondentName,
      isConfirmed: this.report?.isConfirmed
    });
    this.loadReportEntries();
    this.calculateTimeGaps();
  }

  loadReportEntries(): void {
    const entriesFormArray = this.reportForm.get('entries') as FormArray;
    entriesFormArray.clear();
    console.log('this.report:', this.report);

    if (this.report && this.report.reportEntries) {
      console.log('Report entries found:', this.report.reportEntries);
      this.report.reportEntries.forEach(entry => {
        console.log('Adding entry:', entry);
        entriesFormArray.push(this.createProcedureEntry(entry));
      });
    } else {
      console.log('No report entries found.');
    }
    console.log('entriesFormArray после заполнения:', entriesFormArray);
  }

  loadRespondents(): void {
    this.respondentService.getRespondents().subscribe({
      next: respondents => {
        this.respondents = respondents;
      },
      error: error => {
        console.error('Error loading respondents:', error);
      }
    });
  }

  loadProcedures(): void {
    this.procedureService.getProcedures().subscribe({
      next: procedures => {
        this.procedures = procedures;
      },
      error: error => {
        console.error('Error loading procedures:', error);
      }
    });
  }

  addProcedureEntry(): void {
    const entriesFormArray = this.reportForm.get('entries') as FormArray;
    entriesFormArray.push(this.createProcedureEntry());
  }

  removeProcedureEntry(index: number): void {
    const entryId = this.entries.at(index).get('id')?.value;
    if (entryId) {
      this.reportService.deleteReportEntry(this.report.id, entryId).subscribe({
        next: () => {
          this.toastr.info('Запись успешно удалена')
          this.entries.removeAt(index);
        },
        error: error => {
          this.toastr.error(error.error);
        }
      });
    } else {
      this.entries.removeAt(index);
    }
    this.calculateTimeGaps(); // Пересчитать временные интервалы после удаления
  }

  createProcedureEntry(entry?: Entry): FormGroup {
    return this.formBuilder.group({
      id: [{ value: entry?.id, disabled: false }],
      procedureId: [{ value: entry?.procedureId, disabled: false }],
      startTime: [this.formatDate(entry?.startTime)],
      endTime: [this.formatDate(entry?.endTime)],
      comment: [{ value: entry?.comment, disabled: false }],
      isConfirmed: [{ value: entry?.isConfirmed || false, disabled: false }],
    });
  }

  formatDate(date: Date | undefined): string {
    if (!date) {
      return '';
    }
    return formatDate(date, 'yyyy-MM-ddTHH:mm', 'ru');
  }

  get entries(): FormArray {
    return this.reportForm.get('entries') as FormArray;
  }

  submitReport(): void {
    console.log('Submitting report started');

    if (this.reportForm.invalid) {
      console.log('Form is invalid');
      return;
    }
    
    const updatedReportEntries = this.reportForm.value.entries.map((entry: any) => ({
      procedureId: entry.procedureId,
      startTime: new Date(entry.startTime),
      endTime: new Date(entry.endTime),
      comment: entry.comment,
      isConfirmed: true
    }));

    for (let entry of updatedReportEntries) {
      if (!this.checkTimeGapWithinEntry(entry)) {
        console.log('Time gap within entry validation failed');
        this.toastr.error('Некоторые записи начинаются позже (> 5 мин), чем заканчиваются предыдущие')
        return;
      }
    }

    if (!this.checkTimeGapsBetweenEntries(updatedReportEntries)) {
      console.log('Time gaps between entries validation failed');
      return;
    }

    this.reportForm.value.entries.forEach((entry: any, index: number) => {
      const entryData = {
        ...updatedReportEntries[index],
        reportId: this.report?.id,
        agentID: this.report?.agentId,
        respondentId: this.report?.respondentId,
      };

      if (entry.id) {
        this.reportService.confirmReportEntry(this.report!.id!, entry.id).subscribe({
          next: () => {
            console.log('Entry confirmed successfully');
          },
          error: error => {
            console.error('Error confirming entry:', error);
          }
        });
      } else {
        this.reportService.createReportEntry(this.report!.id!, entryData).subscribe({
          next: (newEntry: Entry) => {
            console.log('Entry added successfully:', newEntry);
          },
          error: error => {
            console.error('Error adding entry:', error);
          }
        });
      }
    });

    if (this.report?.id) {
      this.reportService.confirmReport(this.report.id).subscribe({
        next: () => {
          console.log('Report confirmed successfully');
          this.reportStateService.loadReports();
          this.router.navigate(['/reports']);
        },
        error: error => {
          console.error('Error confirming report:', error);
        }
      });
      this.router.navigate(['/reports']);
    }
  }

  saveReport() {
    console.log('Saving report started');

    if (this.reportForm.invalid) {
      console.log('Form is invalid');
      return;
    }

    const updatedReportEntries = this.reportForm.value.entries.map((entry: any) => ({
      procedureId: entry.procedureId,
      startTime: new Date(entry.startTime),
      endTime: new Date(entry.endTime),
      comment: entry.comment,
      isConfirmed: true
    }));

    for (let entry of updatedReportEntries) {
      if (!this.checkTimeGapWithinEntry(entry)) {
        this.toastr.error('Некоторые записи начинаются позже (> 5 мин), чем заканчиваются предыдущие')
        return;
      }
    }

    if (!this.checkTimeGapsBetweenEntries(updatedReportEntries)) {
      this.toastr.error('Некоторые записи начинаются позже (> 5 мин), чем заканчиваются предыдущие')
      return;
    }

    this.reportForm.value.entries.forEach((entry: any, index: number) => {
      const entryData = {
        ...updatedReportEntries[index],
        reportId: this.report?.id,
        agentID: this.report?.agentId,
        respondentId: this.report?.respondentId,
      };

      if (entry.id) {
        this.reportService.updateReportEntry(this.report!.id!, entry.id, entryData).subscribe({
          next: () => {
            this.toastr.info('Запись успешно обновлена')
            console.log('Entry updated successfully');
          },
          error: error => {
            console.error('Error updating entry:', error);
          }
        });
      } else {
        this.reportService.createReportEntry(this.report!.id!, entryData).subscribe({
          next: (newEntry: Entry) => {
            console.log('Entry added successfully:', newEntry);
          },
          error: error => {
            console.error('Error adding entry:', error);
          }
        });
      }
    });

    this.toastr.info('Отчет успешно сохранен')
    console.log('Report saved successfully');
    this.router.navigate(['/reports']);
  }

  calculateTimeGaps(): void {
    const entries = this.reportForm.value.entries;

    if (entries.length === 0) {
      this.timeGaps = [];
      return;
    }

    const sortedEntries = entries
      .map((entry: any) => ({
        startTime: new Date(entry.startTime),
        endTime: new Date(entry.endTime)
      }))
      .sort((a: any, b: any) => a.startTime.getTime() - b.startTime.getTime());

    const timeGaps = [];
    let currentTime = sortedEntries[0].startTime;

    for (let entry of sortedEntries) {
      if (entry.startTime > currentTime) {
        timeGaps.push({ start: currentTime, end: entry.startTime, gap: true });
      }
      timeGaps.push({ start: entry.startTime, end: entry.endTime, gap: false });
      currentTime = entry.endTime;
    }

    this.timeGaps = timeGaps;
  }

  getTimeGapStyles(): string {
    if (!this.timeGaps.length) {
      return '';
    }

    const totalDuration = this.timeGaps[this.timeGaps.length - 1].end.getTime() - this.timeGaps[0].start.getTime();
    const styles = this.timeGaps.map(gap => {
      const startPercent = ((gap.start.getTime() - this.timeGaps[0].start.getTime()) / totalDuration) * 100;
      const widthPercent = ((gap.end.getTime() - gap.start.getTime()) / totalDuration) * 100;
      const backgroundColor = gap.gap ? 'red' : 'green';
      return `left: ${startPercent}%; width: ${widthPercent}%; background-color: ${backgroundColor};`;
    });

    return styles.join(' ');
  }

  checkTimeGapsBetweenEntries(entries: any[]): boolean {
    const sortedEntries = entries
      .map(entry => ({
        startTime: new Date(entry.startTime),
        endTime: new Date(entry.endTime)
      }))
      .sort((a, b) => a.startTime.getTime() - b.startTime.getTime());

    for (let i = 0; i < sortedEntries.length - 1; i++) {
      const gap = sortedEntries[i + 1].startTime.getTime() - sortedEntries[i].endTime.getTime();
      if (gap > 5 * 60 * 1000) {
        return false;
      }
    }
    return true;
  }

  checkTimeGapWithinEntry(entry: any): boolean {
    const startTime = new Date(entry.startTime).getTime();
    const endTime = new Date(entry.endTime).getTime();
    return endTime >= startTime;
  }
}
